{"version":3,"sources":["transit.js"],"names":["define","langx","browser","noder","geom","styler","eventer","transits","transitionProperty","transitionDuration","transitionTiming","transitionDelay","transitionEnd","normalizeCssEvent","supportedTransforms","transform","css3PropPrefix","cssReset","normalizeCssProperty","transit","elm","properties","duration","ease","callback","delay","key","endEvent","wrappedCallback","cssValues","cssProperties","transforms","that","this","fired","hasScrollTop","isPlainObject","easing","complete","undefined","isString","speeds","normal","off","isFunction","eace","size","v","test","top","right","bottom","left","css","width","height","resetClipAuto","push","dasherize","join","event","target","currentTarget","call","on","debounce","clientLeft","scrollToTop"],"mappings":";;;;;;;AAAAA,OAAO,CACH,sBACA,uBACA,qBACA,oBACA,sBACA,uBACA,cACD,SAASC,EAAOC,EAASC,EAAOC,EAAMC,EAAQC,EAAQC,GAErD,IAAIC,EACAC,EACAC,EACAC,EAEAC,EAAgBV,EAAQW,kBAAkB,eAAe,EAEzDC,EAAsB,8EACtBC,EAAYb,EAAQc,eAAiB,YACrCC,EAAW,GAkJf,OAhJAA,EAAST,EAAqBN,EAAQgB,qBAAqB,qBAAqB,GAC5ED,EAASR,EAAqBP,EAAQgB,qBAAqB,qBAAqB,GAChFD,EAASN,EAAkBT,EAAQgB,qBAAqB,kBAAkB,GAC1ED,EAASP,EAAmBR,EAAQgB,qBAAqB,4BAA4B,GAAK,GA6IvFX,EAASY,QAlIhB,SAAiBC,EAAKC,EAAYC,EAAUC,EAAMC,EAAUC,GACxD,IAAIC,EAKAC,EACAC,EALAC,EAAY,GACZC,EAAgB,GAChBC,EAAa,GACbC,EAAOC,KAGPC,EAAQ,CAAA,EACRC,EAAe,CAAA,EAmCnB,IAAKT,KAhCDzB,EAAMmC,cAAcd,CAAQ,IAC5BC,EAAOD,EAASe,OAChBb,EAAWF,EAASgB,SACpBb,EAAQH,EAASG,MACjBH,EAAWA,EAASA,UAMPiB,KAAAA,KAFbjB,EADArB,EAAMuC,SAASlB,CAAQ,EACZf,EAASkC,OAAOnB,GAE3BA,KACAA,EAAWf,EAASkC,OAAOC,QAE/BpB,GAAsB,IAClBf,EAASoC,MACTrB,EAAW,GAGXrB,EAAM2C,WAAWrB,CAAI,GACrBC,EAAWD,EACXsB,KAAO,SAEPtB,EAAOA,GAAQ,QAGfE,EACAA,GAAgB,IAEhBA,EAAQ,EAIAJ,EAAY,CACpB,IAUgByB,EAVZC,EAAI1B,EAAWK,GACfZ,EAAoBkC,KAAKtB,CAAG,EAC5BK,GAAcL,EAAM,IAAMqB,EAAI,MAElB,cAARrB,IACAS,EAAe,CAAA,GAER,QAAPT,GAAiBzB,EAAMmC,cAAcW,CAAC,GACtClB,EAAUH,GAAO,QAAUqB,EAAEE,IAAI,MAAOF,EAAEG,MAAO,MAAOH,EAAEI,OAAQ,MAAOJ,EAAEK,KAAK,MAClD,QAA1B/C,EAAOgD,IAAIjC,EAAI,MAAM,IACjB0B,EAAO1C,EAAK0C,KAAK1B,CAAG,EACxBf,EAAOgD,IAAIjC,EAAI,OAAO,YAAgB0B,EAAKQ,MAAO,MAAOR,EAAKS,OAAc,SAAM,EAClFC,IAIJ3B,EAAUH,GAAOqB,EAErBjB,EAAc2B,KAAKxD,EAAMyD,UAAUhC,CAAG,CAAC,EAE/C,CA8DA,OA7DAC,EAAWf,EAEPmB,IACAF,EAAUd,GAAagB,EACvBD,EAAc2B,KAAK1C,CAAS,GAGjB,EAAXO,IACAO,EAAUrB,GAAsBsB,EAAc6B,KAAK,IAAI,EACvD9B,EAAUpB,GAAsBa,EAAW,IAC3CO,EAAUlB,GAAmBc,EAAQ,IACrCI,EAAUnB,GAAoBa,GAGlCK,EAAkB,SAASgC,GAEvB,GADA1B,EAAQ,CAAA,EACJ0B,EAAO,CACP,GAAIA,EAAMC,SAAWD,EAAME,cACvB,OAEJxD,EAAQqC,IAAIiB,EAAMC,OAAQlC,EAAUC,CAAe,CACvD,MACItB,EAAQqC,IAAIvB,EAAKO,EAAUC,CAAe,EAE9CvB,EAAOgD,IAAIjC,EAAKH,CAAQ,EAIxBO,GAAYA,EAASuC,KAAK9B,IAAI,CAClC,EAEe,EAAXX,IACAhB,EAAQ0D,GAAG5C,EAAKO,EAAUC,CAAe,EAGzC3B,EAAMgE,SAAS,WACP/B,GAGJN,EAAgBmC,KAAK/B,CAAI,CAC7B,EAAyB,KAApBV,EAAWG,GAAiB,EAAE,EAAE,GAIzCL,EAAI8C,WAEJ7D,EAAOgD,IAAIjC,EAAKS,CAAS,EAErBP,GAAY,GACZrB,EAAMgE,SAAS,WACP/B,GAGJN,EAAgBmC,KAAK/B,CAAI,CAC7B,EAAG,CAAC,EAAE,EAGNG,GACA/B,EAAK+D,YAAY/C,EAAKC,EAAsB,UAAGC,EAAUE,CAAQ,EAG9DS,IACX,CAIJ,CAAC","file":"../transit.js","sourcesContent":["define([\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-browser\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-eventer\",\r\n    \"./transits\"\r\n], function(langx, browser, noder, geom, styler, eventer,transits) {\r\n\r\n    var transitionProperty,\r\n        transitionDuration,\r\n        transitionTiming,\r\n        transitionDelay,\r\n\r\n        transitionEnd = browser.normalizeCssEvent('TransitionEnd'),\r\n\r\n        supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,\r\n        transform = browser.css3PropPrefix + \"transform\",\r\n        cssReset = {};\r\n\r\n    cssReset[transitionProperty = browser.normalizeCssProperty(\"transition-property\")] =\r\n        cssReset[transitionDuration = browser.normalizeCssProperty(\"transition-duration\")] =\r\n        cssReset[transitionDelay = browser.normalizeCssProperty(\"transition-delay\")] =\r\n        cssReset[transitionTiming = browser.normalizeCssProperty(\"transition-timing-function\")] = \"\";\r\n\r\n    /*   \r\n     * Perform a custom animation of a set of CSS properties.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} properties\r\n     * @param {String} ease\r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     * @param {Number or String} delay\r\n     */\r\n    function transit(elm, properties, duration, ease, callback, delay) {\r\n        var key,\r\n            cssValues = {},\r\n            cssProperties = [],\r\n            transforms = \"\",\r\n            that = this,\r\n            endEvent,\r\n            wrappedCallback,\r\n            fired = false,\r\n            hasScrollTop = false,\r\n            resetClipAuto = false;\r\n\r\n        if (langx.isPlainObject(duration)) {\r\n            ease = duration.easing;\r\n            callback = duration.complete;\r\n            delay = duration.delay;\r\n            duration = duration.duration;\r\n        }\r\n\r\n        if (langx.isString(duration)) {\r\n            duration = transits.speeds[duration];\r\n        }\r\n        if (duration === undefined) {\r\n            duration = transits.speeds.normal;\r\n        }\r\n        duration = duration / 1000;\r\n        if (transits.off) {\r\n            duration = 0;\r\n        }\r\n\r\n        if (langx.isFunction(ease)) {\r\n            callback = ease;\r\n            eace = \"swing\";\r\n        } else {\r\n            ease = ease || \"swing\";\r\n        }\r\n\r\n        if (delay) {\r\n            delay = delay / 1000;\r\n        } else {\r\n            delay = 0;\r\n        }\r\n\r\n        // CSS transitions\r\n        for (key in properties) {\r\n            var v = properties[key];\r\n            if (supportedTransforms.test(key)) {\r\n                transforms += key + \"(\" + v + \") \";\r\n            } else {\r\n                if (key === \"scrollTop\") {\r\n                    hasScrollTop = true;\r\n                }\r\n                if (key == \"clip\" && langx.isPlainObject(v)) {\r\n                    cssValues[key] = \"rect(\" + v.top+\"px,\"+ v.right +\"px,\"+ v.bottom +\"px,\"+ v.left+\"px)\";\r\n                    if (styler.css(elm,\"clip\") == \"auto\") {\r\n                        var size = geom.size(elm);\r\n                        styler.css(elm,\"clip\",\"rect(\"+\"0px,\"+ size.width +\"px,\"+ size.height +\"px,\"+\"0px)\");  \r\n                        resetClipAuto = true;\r\n                    }\r\n\r\n                } else {\r\n                    cssValues[key] = v;\r\n                }\r\n                cssProperties.push(langx.dasherize(key));\r\n            }\r\n        }\r\n        endEvent = transitionEnd;\r\n\r\n        if (transforms) {\r\n            cssValues[transform] = transforms;\r\n            cssProperties.push(transform);\r\n        }\r\n\r\n        if (duration > 0) {\r\n            cssValues[transitionProperty] = cssProperties.join(\", \");\r\n            cssValues[transitionDuration] = duration + \"s\";\r\n            cssValues[transitionDelay] = delay + \"s\";\r\n            cssValues[transitionTiming] = ease;\r\n        }\r\n\r\n        wrappedCallback = function(event) {\r\n            fired = true;\r\n            if (event) {\r\n                if (event.target !== event.currentTarget) {\r\n                    return // makes sure the event didn't bubble from \"below\"\r\n                }\r\n                eventer.off(event.target, endEvent, wrappedCallback)\r\n            } else {\r\n                eventer.off(elm, endEvent, wrappedCallback) // triggered by setTimeout\r\n            }\r\n            styler.css(elm, cssReset);\r\n            if (resetClipAuto) {\r\n //               styler.css(elm,\"clip\",\"auto\");\r\n            }\r\n            callback && callback.call(this);\r\n        };\r\n\r\n        if (duration > 0) {\r\n            eventer.on(elm, endEvent, wrappedCallback);\r\n            // transitionEnd is not always firing on older Android phones\r\n            // so make sure it gets fired\r\n            langx.debounce(function() {\r\n                if (fired) {\r\n                    return;\r\n                }\r\n                wrappedCallback.call(that);\r\n            }, ((duration + delay) * 1000) + 25)();\r\n        }\r\n\r\n        // trigger page reflow so new elements can transit\r\n        elm.clientLeft;\r\n\r\n        styler.css(elm, cssValues);\r\n\r\n        if (duration <= 0) {\r\n            langx.debounce(function() {\r\n                if (fired) {\r\n                    return;\r\n                }\r\n                wrappedCallback.call(that);\r\n            }, 0)();\r\n        }\r\n\r\n        if (hasScrollTop) {\r\n            geom.scrollToTop(elm, properties[\"scrollTop\"], duration, callback);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return transits.transit = transit;\r\n\r\n});"]}